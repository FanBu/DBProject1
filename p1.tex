\documentclass[letter, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{spverbatim}
\graphicspath{ {images/} }

\title{
	{Project Report}\\
	{\large CS6083 Project \#1}}
\author{Fan Bu \\ fb1102@nyu.edu \and Bohan Zhang \\ bz906@nyu.edu}
\date{\today}

\usepackage[left=1in, right=1in, top=1in, bottom=0.5in, includefoot, headheight=13.6pt]{geometry}
\usepackage{natbib}
\usepackage{enumerate}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{fancyhdr}
\pagestyle{fancy}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\fancyhead{}
\fancyhead[RO,LE]{Project Report - CS6083 Project \#1}
\fancyfoot{}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,CE]{Chapter \thechapter}

\usepackage{tikz}
\usetikzlibrary{er}


% database
\def\ojoin{\setbox0=\hbox{$\bowtie$}%
	\rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}} 





\begin{document}
	\maketitle
	
	\tableofcontents
	
	\chapter{Introduction}
	In the first part this project, we have designed a relational database that can serve as a relational
	backend for the service of a music streaming service similar to, e.g., Spotify. And this report will show the whole process of design and testing, as well as some interesting details when building the database.
	
	\chapter{Design}
	\section{ER Diagram}
	Our ER Diagram is as follows.
	\begin{center}
	\includegraphics[width=1\textwidth]{ER1}
	\end{center}
	As we designed this ER diagram, we made the following assumptions.
	\begin{enumerate}
		\item 
		Album and playlist are modeled together to better represent the relation between user, playlist, album, and track. Since when a user plays a song, we want to store where the user finds the song, which could be from an album or a playlist, or the user found this song from search. If we seperate album and playlist, we still can trace the relation when building the website, but it will not be elegant to model it in ER diagram.
		\item 
		A playlist is created by a user, and a user can create many playlists.
		\item 
		A track, which is a piece of music, is performed by a single artist. And a single artist, which in fact can be a single person or a music band, can play many tracks.
		\item 
		A user can only play one track at a moment.
		\item 
		PlayHistory is a weak entity, and it has a partial key, time.
		\item 
		Every entity in the PlayHistory entity set participates in at least one relationship in the plays relationship set. And every entity in the PlayHistory entity set participates in at least one relationship in the with relationship set. But entities in PlayHistory is allowed not to participate in the any relationship in from relashiship set, which allows a user play a song directly rather than from any album or playlist.
		\item 
		A user can only follow another user once, which means the status between a user and another is either followed or not followed. After a user unfollowing another user, he can follow the specific user again.
	\end{enumerate}
	\section{Relational Schema}
	\subsection{Relational Schema and Keys}
	And the Relational Schemas are as follows.\\
	User(\underline{\smash{uid}}, uname, nickname, email, city, password)\\
	Artist(\underline{\smash{aid}}, aname, description)\\
	Track(\underline{\smash{tid}}, title, duration, genre, by\_aid)\\
	AlbumPlaylist(\underline{\smash{alid}}, title, time, count, type, by\_uid)\\
	PlayHistory(\underline{\smash{uid}}, \underline{\smash{time}}, tid, alid)\\
	Follow(\underline{\smash{uid}}, \underline{\smash{f\_uid}}, time)\\
	Rating(\underline{\smash{uid}}, \underline{\smash{time}}, tid, rate)\\
	Like(\underline{\smash{uid}}, \underline{\smash{time}}, aid)\\
	TrackAlbum(\underline{\smash{tid}}, \underline{\smash{alid}}, order)\\
	The attributes with underlines are the keys of the corresponding relation.
	\subsection{Foreign Keys}
	Foreign key Track(by\_aid) references Artist(aid).\\
	Foreign key AlbumPlaylist(by\_uid) references User(uid).\\
	Foreign key PlayHistory(uid) references User(uid).\\
	Foreign key PlayHistory(tid) references Track(tid).\\
	Foreign key PlayHistory(alid) references AlbumPlaylist(alid).\\
	Foreign key Follow(uid) references User(uid).\\
	Foreign key Follow(f\_uid) references User(uid).\\
	Foreign key Rating(uid) references User(uid).\\
	Foreign key Rating(tid) references Track(tid).\\
	Foreign key Like(uid) references User(uid).\\
	Foreign key Like(aid) references Artist(aid).\\
	Foreign key TrackAlbum(tid) references Track(tid).\\
	Foreign key TrackAlbum(alid) references AlbumPlaylist(alid).\\
	
	\section{Database Schemas}
	\subsection{Database Schemas Script}
	Database schemas are as follows.
	\begin{spverbatim}
	CREATE TABLE `Artist` (
	`aid` int(11) NOT NULL AUTO_INCREMENT,
	`aname` varchar(45) NOT NULL,
	`description` varchar(200) NOT NULL,
	PRIMARY KEY (`aid`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Track` (
	`tid` int(11) NOT NULL AUTO_INCREMENT,
	`duration` int(11) NOT NULL,
	`title` varchar(45) NOT NULL,
	`genre` varchar(45) NOT NULL,
	`by_aid` int(11) NOT NULL,
	PRIMARY KEY (`tid`),
	KEY `by_aid` (`by_aid`),
	CONSTRAINT `Track_ibfk_1` FOREIGN KEY (`by_aid`) REFERENCES `Artist` (`aid`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
	
	CREATE TABLE `User` (
	`uid` int(11) NOT NULL AUTO_INCREMENT,
	`uname` varchar(45) NOT NULL,
	`nickname` varchar(45) DEFAULT NULL,
	`email` varchar(45) DEFAULT NULL,
	`password` varchar(10) NOT NULL,
	`city` varchar(45) DEFAULT NULL,
	PRIMARY KEY (`uid`),
	UNIQUE KEY `uname` (`uname`),
	UNIQUE KEY `email` (`email`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8
	
	CREATE TABLE `AlbumPlaylist` (
	`alid` int(11) NOT NULL AUTO_INCREMENT,
	`title` varchar(200) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	`type` enum('album','playlist') DEFAULT NULL,
	`count` int(11) NOT NULL,
	`by_uid` int(11) DEFAULT NULL,
	PRIMARY KEY (`alid`),
	KEY `by_uid` (`by_uid`),
	CONSTRAINT `AlbumPlaylist_ibfk_1` FOREIGN KEY (`by_uid`) REFERENCES `User` (`uid`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Follow` (
	`uid` int(11) NOT NULL,
	`f_uid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (`uid`,`f_uid`),
	KEY `f_uid` (`f_uid`),
	CONSTRAINT `Follow_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `Follow_ibfk_2` FOREIGN KEY (`f_uid`) REFERENCES `User` (`uid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Likes` (
	`uid` int(11) NOT NULL,
	`aid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (`uid`,`time`),
	KEY `aid` (`aid`),
	CONSTRAINT `Likes_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `Likes_ibfk_2` FOREIGN KEY (`aid`) REFERENCES `Artist` (`aid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `PlayHistory` (
	`uid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	`tid` int(11) NOT NULL,
	`alid` int(11) NOT NULL,
	PRIMARY KEY (`uid`,`time`),
	KEY `tid` (`tid`),
	KEY `alid` (`alid`),
	CONSTRAINT `PlayHistory_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `PlayHistory_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `Track` (`tid`),
	CONSTRAINT `PlayHistory_ibfk_3` FOREIGN KEY (`alid`) REFERENCES `AlbumPlaylist` (`alid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Rating` (
	`uid` int(11) NOT NULL,
	`tid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	`rate` int(1) NOT NULL,
	PRIMARY KEY (`uid`,`tid`),
	KEY `tid` (`tid`),
	CONSTRAINT `Rating_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `Rating_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `Track` (`tid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `TrackAlbum` (
	`tid` int(11) NOT NULL,
	`alid` int(11) NOT NULL,
	`order` int(11) NOT NULL,
	PRIMARY KEY (`tid`,`alid`),
	KEY `alid` (`alid`),
	CONSTRAINT `TrackAlbum_ibfk_1` FOREIGN KEY (`alid`) REFERENCES `AlbumPlaylist` (`alid`),
	CONSTRAINT `TrackAlbum_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `Track` (`tid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	\end{spverbatim}
	\subsection{Explanation}
	\subsubsection{The reason why we choose VARCHAR rather than TEXT.}
	TEXT is stored off the table, and the table has a pointer to the location of the actual storage. So when the data is not in cache, generally, it will consume 1 more disk read before getting the real data. And VARCHAR is stored inside the table, which could be faster. But the downside of VARCHAR is obvious, it will make the blocks contain less rows, and may increase the disk read time if we are doing a scan read. And one more advantage for VARCHAR is that there can be INDEX on VARCHAR, and can not be INDEX other than FULLTEXT on TEXT, so it could be good for our queries.\\
	Currently, we believe that we don't have huge description of artist, so we choose to use VARCHAR for now. And if in future, we have heavy load on the text, we can change them into TEXT.
	
	\subsection{}
	
	
	\chapter{Testing}
	
	\section{Normalization Validation}
	In this part, we checked multiple normalization requirements. The reason why we do so is to achieve the following goals:
	\begin{enumerate}
		\item 
		Avoid redundant data.
		\item 
		Ensure that relationships among attributes are represented.
		\item 
		Facilatate the checking of updates for violation of database integrity constraints.
	\end{enumerate}
	\subsection{First Normal Form Validation}
	In our current situation, every domain in our relational schemas is considered to be indivisible unit, hence every domain is atomic. So the requirements of first normal form is met.
	\subsection{Boyce-Codd Normal Form Validation}
	To check whether the schemas are in BCNF we have to figure out every functional dependency first.
	\subsubsection{Functional Dependencies}
	Following are the all non-trivial functional dependencies.\\
	$(uid\to uname, nickname, email, city, password)$\\
	$(uname\to uid, nickname, email, city, password)$\\
	$(email\to uid, uname ,nickname, city, password)$\\
	$(aid\to aname, description)$\\
	$(tid\to title, duration, genre, by\_aid)$\\
	$(alid\to title, time, count, type, by\_uid)$\\
	$(uid, time\to tid, alid)$\\
	$(uid, f\_uid\to time)$\\
	$(uid, time\to f\_uid)$\\
	$(uid, time\to tid, rate)$\\
	$(uid, tid\to time, rate)$\\
	$(uid, time\to aid)$\\
	$(uid, aid\to time)$\\
	$(tid, alid\to order)$\\
	$(alid, order\to tid)$\\
	As we can see, every functional dependency above, with the form of $\alpha \to \beta$, has the property of that $\alpha$ is a superkey for the corresponding relation schema $R$. So we can say that our relational schemas are in Boyce-Codd Normal Form.
	
	\subsection{Third Normal Form Validation}
	Since every relation schema is in BCNF, it's in Third Normal Form, too.
	\subsection{Fourth Normal Form Validation}
	Since there is not multivalued dependency in any relational schema, so every relational schema is in Fourth Normal Form.
	

	\section{Sample Queries and Results}
	\subsection{Query 1}
	Create a record for a new user account, with a name, a login name, and a password.
	\subsubsection{SQL Script}
	\begin{spverbatim}
		INSERT INTO User(nickname, uname, password) VALUES ('Jeremy Bo', 'jbj', 'pass');
	\end{spverbatim}
	\subsubsection{Result}
	
	\subsection{Query 2}
	For each artist, list their ID, name, and how many times their tracks have been played by users.
	\subsubsection{SQL Script}
	\begin{spverbatim}
		SELECT aid, aname, (playcounttable.playcount) AS count 
		FROM Artist LEFT JOIN
		(SELECT COUNT(Track.tid) AS playcount, by_aid 
		FROM Track, PlayHistory
		WHERE Track.tid = PlayHistory.tid
		GROUP BY by_aid) AS playcounttable
		ON Artist.aid = playcounttable.by_aid;
	\end{spverbatim}
	\subsubsection{Result}
	
	\subsection{Query 3}
	List all artists that are mainly playing Jazz, meaning that at least half of their tracks are of genre Jazz.
	\subsubsection{SQL Script}
	\begin{spverbatim}
		SELECT Artist.aid, aname, description FROM
		(SELECT COUNT(tid) AS jazzcount, by_aid
		FROM Track
		WHERE genre = 'Jazz'
		GROUP BY by_aid) AS jazzcounttable,
		(SELECT COUNT(tid) AS totalcount, by_aid
		FROM Track
		GROUP BY by_aid) AS totalcounttable, Artist
		WHERE jazzcounttable.by_aid = totalcounttable.by_aid
		AND jazzcounttable.by_aid = Artist.aid
		AND 2 * jazzcount >= totalcount;
	\end{spverbatim}
	\subsubsection{Result}
	
	\subsection{Query 4}
	Insert a new rating given by a user for a track.
	\subsubsection{SQL Script}
	\begin{spverbatim}
		INSERT INTO Rating(uid, tid, time, rate) VALUES (4, 1, '2017-11-30 12:50:00', 5);
	\end{spverbatim}
	\subsubsection{Result}
	
	\subsection{Query 5}
	For a particular user, say “NancyInQueens”, list all playlists that were made by users that she follows.
	\subsubsection{SQL Script}
	\begin{spverbatim}
		SELECT alid, title, time, type, count, by_uid FROM AlbumPlaylist,
		(SELECT f_uid FROM Follow, User
		WHERE Follow.uid = User.uid
		AND uname = 'NancyInQueens') AS uidtable
		WHERE AlbumPlaylist.type = 'playlist'
		AND AlbumPlaylist.by_uid = uidtable.f_uid;
	\end{spverbatim}
	\subsubsection{Result}
	
	\subsection{Query 6}
	List all songs where the track title or artist title matches some set of keywords (if possible, use
	``contains'', or otherwise ``like'', for this query).
	
	\subsubsection{SQL Script}
	\begin{spverbatim}
		SELECT alid, title, time, type, count, by_uid FROM AlbumPlaylist,
		(SELECT f_uid FROM Follow, User
		WHERE Follow.uid = User.uid
		AND uname = 'NancyInQueens') AS uidtable
		WHERE AlbumPlaylist.type = 'playlist'
		AND AlbumPlaylist.by_uid = uidtable.f_uid;
	\end{spverbatim}
	\subsubsection{Result}
	
	\subsection{Query 7}
	Find pairs of related artists, where two artists are related if they have many fans in common. (Define
	this appropriately.)
	\subsubsection{SQL Script}
	\begin{spverbatim}
		SELECT counttotaltable.aid AS aid1, commontable.aid2
		FROM (SELECT aid, COUNT(uid) AS countuid FROM Likes GROUP BY aid) AS counttotaltable,
		(SELECT likes1.aid AS aid1, likes2.aid AS aid2, COUNT(likes1.uid) AS countcommon
		FROM Likes likes1, Likes likes2
		WHERE likes1.uid = likes2.uid
		GROUP BY likes1.aid, likes2.aid) AS commontable
		WHERE NOT counttotaltable.aid = commontable.aid2
		AND counttotaltable.aid = commontable.aid1
		AND counttotaltable.countuid <= commontable.countcommon * 10;
	\end{spverbatim}
	\subsubsection{Result}
\end{document}