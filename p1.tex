\documentclass[letter, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{spverbatim}
\graphicspath{ {images/} }

\title{
	{Project Report}\\
	{\large CS6083 Project \#1}}
\author{Fan Bu \\ fb1102@nyu.edu \and Bohan Zhang \\ bz906@nyu.edu}
\date{\today}

\usepackage[left=1in, right=1in, top=1in, bottom=0.5in, includefoot, headheight=13.6pt]{geometry}
\usepackage{natbib}
\usepackage{enumerate}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{fancyhdr}
\pagestyle{fancy}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\fancyhead{}
\fancyhead[RO,LE]{Project Report - CS6083 Project \#1}
\fancyfoot{}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,CE]{Chapter \thechapter}

\usepackage{tikz}
\usetikzlibrary{er}


% database
\def\ojoin{\setbox0=\hbox{$\bowtie$}%
	\rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}} 





\begin{document}
	\maketitle
	
	\tableofcontents
	
	\chapter{Introduction}
	In the first part this project, we have designed a relational database that can serve as a relational
	backend for the service of a music streaming service similar to, e.g., Spotify. And this report will show the whole process of design and testing, as well as some interesting details when building the database.
	
	\chapter{Design}
	\section{ER Diagram}
	Our ER Diagram is as follows.
	\begin{center}
	\includegraphics[width=1\textwidth]{ER1}
	\end{center}
	As we designed this ER diagram, we made the following assumptions.
	\begin{enumerate}
		\item 
		Album and playlist are modeled together to better represent the relation between user, playlist, album, and track. Since when a user plays a song, we want to store where the user finds the song, which could be from an album or a playlist, or the user found this song from search. If we seperate album and playlist, we still can trace the relation when building the website, but it will not be elegant to model it in ER diagram.
		\item 
		A playlist is created by a user, and a user can create many playlists.
		\item 
		A track, which is a piece of music, is performed by a single artist. And a single artist, which in fact can be a single person or a music band, can play many tracks.
		\item 
		A user can only play one track at a moment.
		\item 
		PlayHistory is a weak entity, and it has a partial key, time.
		\item 
		Every entity in the PlayHistory entity set participates in at least one relationship in the plays relationship set. And every entity in the PlayHistory entity set participates in at least one relationship in the with relationship set. But entities in PlayHistory is allowed not to participate in the any relationship in from relashiship set, which allows a user play a song directly rather than from any album or playlist.
		\item 
		A user can only follow another user once, which means the status between a user and another is either followed or not followed. After a user unfollowing another user, he can follow the specific user again.
	\end{enumerate}
	\section{Relational Schema}
	\subsection{Relational Schema and Keys}
	And the Relational Schemas are as follows.\\
	User(\underline{\smash{uid}}, uname, nickname, email, city, password)\\
	Artist(\underline{\smash{aid}}, aname, description)\\
	Track(\underline{\smash{tid}}, title, duration, genre, by\_aid)\\
	AlbumPlaylist(\underline{\smash{alid}}, title, time, count, type, by\_uid)\\
	PlayHistory(\underline{\smash{uid}}, \underline{\smash{time}}, tid, alid)\\
	Follow(\underline{\smash{uid}}, \underline{\smash{f\_uid}}, time)\\
	Rating(\underline{\smash{uid}}, \underline{\smash{time}}, tid, rate)\\
	Like(\underline{\smash{uid}}, \underline{\smash{time}}, aid)\\
	TrackAlbum(\underline{\smash{tid}}, \underline{\smash{alid}}, order)\\
	The attributes with underlines are the keys of the corresponding relation.
	\subsection{Foreign Keys}
	Foreign key Track(by\_aid) references Artist(aid).\\
	Foreign key AlbumPlaylist(by\_uid) references User(uid).\\
	Foreign key PlayHistory(uid) references User(uid).\\
	Foreign key PlayHistory(tid) references Track(tid).\\
	Foreign key PlayHistory(alid) references AlbumPlaylist(alid).\\
	Foreign key Follow(uid) references User(uid).\\
	Foreign key Follow(f\_uid) references User(uid).\\
	Foreign key Rating(uid) references User(uid).\\
	Foreign key Rating(tid) references Track(tid).\\
	Foreign key Like(uid) references User(uid).\\
	Foreign key Like(aid) references Artist(aid).\\
	Foreign key TrackAlbum(tid) references Track(tid).\\
	Foreign key TrackAlbum(alid) references AlbumPlaylist(alid).\\
	
	
	\section{Normalization Validation}
	In this part, we checked multiple normalization requirements. The reason why we do so is to achieve the following goals:
	\begin{enumerate}
		\item 
		Avoid redundant data.
		\item 
		Ensure that relationships among attributes are represented.
		\item 
		Facilatate the checking of updates for violation of database integrity constraints.
	\end{enumerate}
	\subsection{First Normal Form Validation}
	In our current situation, every domain in our relational schemas is considered to be indivisible unit, hence every domain is atomic. So the requirements of first normal form is met.
	\subsection{Boyce-Codd Normal Form Validation}
	To check whether the schemas are in BCNF we have to figure out every functional dependency first.
	\subsubsection{Functional Dependencies}
	Following are the all non-trivial functional dependencies.\\
	$(uid\to uname, nickname, email, city, password)$\\
	$(uname\to uid, nickname, email, city, password)$\\
	$(email\to uid, uname ,nickname, city, password)$\\
	$(aid\to aname, description)$\\
	$(tid\to title, duration, genre, by\_aid)$\\
	$(alid\to title, time, count, type, by\_uid)$\\
	$(uid, time\to tid, alid)$\\
	$(uid, f\_uid\to time)$\\
	$(uid, time\to f\_uid)$\\
	$(uid, time\to tid, rate)$\\
	$(uid, tid\to time, rate)$\\
	$(uid, time\to aid)$\\
	$(uid, aid\to time)$\\
	$(tid, alid\to order)$\\
	$(alid, order\to tid)$\\
	As we can see, every functional dependency above, with the form of $\alpha \to \beta$, has the property of that $\alpha$ is a superkey for the corresponding relation schema $R$. So we can say that our relational schemas are in Boyce-Codd Normal Form.
	
	\subsection{Third Normal Form Validation}
	Since every relation schema is in BCNF, it's in Third Normal Form, too.
	\subsection{Fourth Normal Form Validation}
	Since there is not multivalued dependency in any relational schema, so every relational schema is in Fourth Normal Form.
	
	\section{Database Schema}
	Database schemas are as follows.
	\begin{spverbatim}
	CREATE TABLE `Artist` (
	`aid` int(11) NOT NULL AUTO_INCREMENT,
	`aname` varchar(45) NOT NULL,
	`description` varchar(200) NOT NULL,
	PRIMARY KEY (`aid`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Track` (
	`tid` int(11) NOT NULL AUTO_INCREMENT,
	`duration` int(11) NOT NULL,
	`title` varchar(45) NOT NULL,
	`genre` varchar(45) NOT NULL,
	`by_aid` int(11) NOT NULL,
	PRIMARY KEY (`tid`),
	KEY `by_aid` (`by_aid`),
	CONSTRAINT `Track_ibfk_1` FOREIGN KEY (`by_aid`) REFERENCES `Artist` (`aid`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
	
	CREATE TABLE `User` (
	`uid` int(11) NOT NULL AUTO_INCREMENT,
	`uname` varchar(45) NOT NULL,
	`nickname` varchar(45) DEFAULT NULL,
	`email` varchar(45) DEFAULT NULL,
	`password` varchar(10) NOT NULL,
	`city` varchar(45) DEFAULT NULL,
	PRIMARY KEY (`uid`),
	UNIQUE KEY `uname` (`uname`),
	UNIQUE KEY `email` (`email`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8
	
	CREATE TABLE `AlbumPlaylist` (
	`alid` int(11) NOT NULL AUTO_INCREMENT,
	`title` varchar(200) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	`type` enum('album','playlist') DEFAULT NULL,
	`count` int(11) NOT NULL,
	`by_uid` int(11) DEFAULT NULL,
	PRIMARY KEY (`alid`),
	KEY `by_uid` (`by_uid`),
	CONSTRAINT `AlbumPlaylist_ibfk_1` FOREIGN KEY (`by_uid`) REFERENCES `User` (`uid`)
	) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Follow` (
	`uid` int(11) NOT NULL,
	`f_uid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (`uid`,`f_uid`),
	KEY `f_uid` (`f_uid`),
	CONSTRAINT `Follow_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `Follow_ibfk_2` FOREIGN KEY (`f_uid`) REFERENCES `User` (`uid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Likes` (
	`uid` int(11) NOT NULL,
	`aid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (`uid`,`time`),
	KEY `aid` (`aid`),
	CONSTRAINT `Likes_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `Likes_ibfk_2` FOREIGN KEY (`aid`) REFERENCES `Artist` (`aid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `PlayHistory` (
	`uid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	`tid` int(11) NOT NULL,
	`alid` int(11) NOT NULL,
	PRIMARY KEY (`uid`,`time`),
	KEY `tid` (`tid`),
	KEY `alid` (`alid`),
	CONSTRAINT `PlayHistory_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `PlayHistory_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `Track` (`tid`),
	CONSTRAINT `PlayHistory_ibfk_3` FOREIGN KEY (`alid`) REFERENCES `AlbumPlaylist` (`alid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `Rating` (
	`uid` int(11) NOT NULL,
	`tid` int(11) NOT NULL,
	`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	`rate` int(1) NOT NULL,
	PRIMARY KEY (`uid`,`tid`),
	KEY `tid` (`tid`),
	CONSTRAINT `Rating_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `User` (`uid`),
	CONSTRAINT `Rating_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `Track` (`tid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	
	CREATE TABLE `TrackAlbum` (
	`tid` int(11) NOT NULL,
	`alid` int(11) NOT NULL,
	`order` int(11) NOT NULL,
	PRIMARY KEY (`tid`,`alid`),
	KEY `alid` (`alid`),
	CONSTRAINT `TrackAlbum_ibfk_1` FOREIGN KEY (`alid`) REFERENCES `AlbumPlaylist` (`alid`),
	CONSTRAINT `TrackAlbum_ibfk_2` FOREIGN KEY (`tid`) REFERENCES `Track` (`tid`)
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	\end{spverbatim}
	
	\chapter{Testing}
	\section{Sample Queries and Result}
	\subsection{Query 1}
	Create a record for a new user account, with a name, a login name, and a password.
	\subsubsection{Query}
	\begin{spverbatim}
		INSERT INTO User(nickname, uname, password) VALUES ('Jeremy Bo', 'jbj', 'pass');
	\end{spverbatim}
	\subsubsection{Result}
	
\end{document}